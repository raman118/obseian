The C++ linker is a critical component in the compilation toolchain that transforms object files into executable programs. Let's explore how it works in detail.

## Linker Functionality

The linker (often called ld on Unix-like systems) takes the object files generated by the compiler and combines them into a single executable file, shared library, or another object file. Its primary responsibilities include:

- Combining multiple object files into a single executable
    
- Resolving symbol references between object files
    
- Incorporating code from static and dynamic libraries
    
- Arranging sections of code and data in memory
    
- Performing relocations to adjust memory addresses
    

## Symbol Resolution

One of the linker's most important tasks is symbol resolution:

- **Symbol Table Processing**: Each object file contains a symbol table listing all symbols (functions, variables) it defines or references
    
- **External Symbol Resolution**: The linker matches external symbol references in one object file with their definitions in other object files or libraries
    
- **Undefined Symbols**: If a symbol is referenced but not defined in any input file, the linker reports an "undefined symbol" error
    

For example, if `main.o` calls a function defined in `helper.o`, the linker connects these references so the final program knows where to find the function's code.

## Library Linking

The linker handles two types of libraries:

- **Static Libraries (.a files)**: Collections of object files bundled together; the linker extracts and incorporates only the needed object files into the final executable
    
- **Dynamic Libraries (.so/.dll files)**: Referenced by the executable but loaded at runtime; the linker includes information about which libraries are needed and what symbols they provide
    

When linking with static libraries, the linker follows a specific order:

1. It processes object files and libraries in the order specified on the command line
    
2. It only extracts object files from libraries that resolve currently undefined symbols
    
3. It may need multiple passes through libraries to resolve all dependencies
    

## Relocation Process

Relocation is a crucial linker function:

- **Address Assignment**: The linker assigns final memory addresses to all code and data sections
    
- **Relocation Records**: Object files contain relocation records that identify locations in the code where addresses need to be adjusted
    
- **Patching Code**: The linker updates these locations with the correct final addresses
    

For instance, when your code calls a function, the compiler generates a placeholder address, and the linker replaces it with the actual address where that function will reside in memory.

## Link-Time Optimization

Modern linkers often perform optimizations:

- **Dead Code Elimination**: Removing unused functions and data
    
- **Function Inlining**: Replacing function calls with the function body
    
- **Interprocedural Analysis**: Optimizing across multiple compilation units
    

## Linker Command Structure

A typical linker command might look like:

bash

`ld -o program main.o helper.o -lm`

This instructs the linker to:

- Create an output file named "program"
    
- Include the object files main.o and helper.o
    
- Link with the math library (libm)
    

## Linker Errors

Common linker errors include:

- **Undefined reference**: A symbol is used but not defined anywhere
    
- **Multiple definition**: The same symbol is defined in more than one object file
    
- **Unresolved external symbol**: Similar to undefined reference, often seen in Windows environments
    

These errors occur during the linking phase rather than the compilation phase, which is why they only appear after all files compile successfully.

---

Answer from Perplexity: [pplx.ai/share](https://www.perplexity.ai/search/pplx.ai/share)